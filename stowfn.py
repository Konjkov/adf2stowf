#!/usr/bin/env python3

# (C) 2008 Norbert Nemec
# This file is part of the CASINO distribution.
# Permission is given to use the script along with the CASINO program and modify
# it for personal use.


from common import *
import stowfn_cpp

num_orbs_per_shelltype = np.array([0,1,4,3,5,7,9])


class stowfn:
    def __init__(self,fname=None):
        if fname is not None:
            self.readfile(fname)
        else:
            self.initempty()

    def initempty(self):
        pass

    def readfile(self,fname):
        f=file(fname)

        def readline():
            return f.readline()
        def readstr():
            return readline().strip()
        def readint():
            return int(readstr())
        def readfloat():
            return float(readstr())
        def readfloats(N):
            res = []
            while len(res) < N:
                l = readline()
                res += [ float(l[i:i+20]) for i in range(0,len(l)-1,20) ]
            assert len(res) == N
            return np.array(res)
        def readints(N):
            res = []
            while len(res) < N:
                res += [ int(n) for n in readline().split() ]
            assert len(res) == N
            return np.array(res)
        def readbool():
            return F2P_bool[readstr()]
        def skipline(text=""):
            l=f.readline()
            assert l==text+"\n"

        self.title=readstr()
        skipline()
        skipline("BASIC INFO")
        skipline("----------")
        skipline("Generated by:")
        self.code = readstr()
        skipline("Periodicity:")
        self.periodicity = readint()
        skipline("Spin unrestricted:")
        self.spin_unrestricted = readbool()
        skipline("Nuclear repulsion energy (au/atom):")
        self.nuclear_repulsion_energy = readfloat()
        skipline("Number of electrons")
        self.num_elec = readint()
        skipline()
        skipline("GEOMETRY")
        skipline("--------")
        skipline("Number of atoms")
        self.num_atom = readint()
        skipline("Atomic positions (au)")
        self.atompos=readfloats(self.num_atom*3).reshape((self.num_atom,3))
        skipline("Atomic numbers for each atom")
        self.atomnum = readints(self.num_atom)
        skipline("Valence charges for each atom")
        self.atomcharge = readfloats(self.num_atom)
        skipline()
        skipline("BASIS SET")
        skipline("---------")
        skipline("Number of STO centres")
        self.num_centres = readint()
        skipline("Position of each centre (au)")
        self.centrepos = readfloats(self.num_centres*3).reshape((self.num_centres,3))
        skipline("Number of shells")
        self.num_shells = readint()
        skipline("Sequence number of first shell on each centre")
        self.idx_first_shell_on_centre = np.array(list(readints(self.num_centres) - 1) + [self.num_shells])
        skipline("Code for shell types (s/sp/p/d/f/g 1/2/3/4/5/6)")
        self.shelltype = readints(self.num_shells)
        skipline("Order of radial prefactor r in each shell")
        self.order_r_in_shell = readints(self.num_shells)
        skipline("Exponent in each STO shell")
        self.zeta = readfloats(self.num_shells)
        skipline("Number of basis functions ('AO')")
        self.num_atorbs = readint()
        skipline("Number of molecular orbitals ('MO')")
        self.num_molorbs = readints(1+self.spin_unrestricted)
        skipline()

        assert self.idx_first_shell_on_centre[-1] == self.num_shells
        assert self.idx_first_shell_on_centre[0] == 0

        self.num_shells_on_centre = self.idx_first_shell_on_centre[1:] - self.idx_first_shell_on_centre[:-1]
        self.max_order_r_on_centre = np.array([
            max(2,self.order_r_in_shell[self.idx_first_shell_on_centre[i]:self.idx_first_shell_on_centre[i+1]].max())
            for i in range(self.num_centres)
        ])
        self.max_order_r = self.max_order_r_on_centre.max()
        self.max_shell_type_on_centre = np.array([
            self.shelltype[self.idx_first_shell_on_centre[i]:self.idx_first_shell_on_centre[i+1]].max()
            for i in range(self.num_centres)
        ])
        assert all(self.num_shells_on_centre > 0)
        assert sum(num_orbs_per_shelltype[self.shelltype]) == self.num_atorbs

        skipline("MULTIDETERMINANT INFORMATION")
        skipline("----------------------------")
        skipline("GS")
        skipline()

        line = readline()
        if line == "ORBITAL COEFFICIENTS (normalized AO)\n":
            skipline("------------------------------------")
            self.coeff = [ readfloats(self.num_molorbs[0]*self.num_atorbs).reshape((self.num_molorbs[0],self.num_atorbs)) ]
            if self.spin_unrestricted:
                self.coeff += [ readfloats(self.num_molorbs[1]*self.num_atorbs).reshape((self.num_molorbs[1],self.num_atorbs)) ]
            self.coeff_norm = [ c[:,:] * self.get_norm()[None,:] for c in self.coeff ]
            skipline()
            self.footer = f.readlines()
        else:
            self.coeff = [ np.zeros((self.num_molorbs[0],self.num_atorbs)) ]
            if self.spin_unrestricted:
                self.coeff += [ np.zeros((self.num_molorbs[1],self.num_atorbs)) ]
            self.coeff_norm = [ c[:,:]*0.0 for c in self.coeff ]
            self.footer = [line] + f.readlines()
        f.close()

    def check_and_normalize(self):
        self.title            = str(self.title)
        self.code              = str(self.code)
        self.periodicity       = int(self.periodicity)
        self.spin_unrestricted = bool(self.spin_unrestricted)
        self.nuclear_repulsion_energy = float(self.nuclear_repulsion_energy)
        self.num_elec = int(self.num_elec)
        self.num_atom = int(self.num_atom)
        assert self.atompos.shape == (self.num_atom,3)
        assert np.issubdtype(self.atompos.dtype,float)
        assert self.atomnum.shape == (self.num_atom,)
        assert np.issubdtype(self.atomnum.dtype,int)
        assert self.atomcharge.shape == (self.num_atom,)
        assert np.issubdtype(self.atomcharge.dtype,float)
        self.num_centres = int(self.num_centres)
        assert self.centrepos.shape == (self.num_centres,3)
        assert np.issubdtype(self.centrepos.dtype,float)
        self.num_shells = int(self.num_shells)
        assert self.idx_first_shell_on_centre.shape == (self.num_centres+1,)
        assert np.issubdtype(self.idx_first_shell_on_centre.dtype,int)
        assert self.shelltype.shape == (self.num_shells,)
        assert np.issubdtype(self.shelltype.dtype,int)
        assert self.order_r_in_shell.shape == (self.num_shells,)
        assert np.issubdtype(self.order_r_in_shell.dtype,int)
        assert self.zeta.shape == (self.num_shells,)
        assert np.issubdtype(self.zeta.dtype,float)
        self.num_atorbs = int(self.num_atorbs)
        assert self.num_molorbs.shape == (1+self.spin_unrestricted,)

        assert self.idx_first_shell_on_centre[-1] == self.num_shells
        assert self.idx_first_shell_on_centre[0] == 0

        self.num_shells_on_centre = self.idx_first_shell_on_centre[1:] - self.idx_first_shell_on_centre[:-1]
        self.max_order_r_on_centre = np.array([
            max(2,self.order_r_in_shell[self.idx_first_shell_on_centre[i]:self.idx_first_shell_on_centre[i+1]].max())
            for i in range(self.num_centres)
        ])
        self.max_order_r = self.max_order_r_on_centre.max()
        self.max_shell_type_on_centre = np.array([
            self.shelltype[self.idx_first_shell_on_centre[i]:self.idx_first_shell_on_centre[i+1]].max()
            for i in range(self.num_centres)
        ])
        assert all(self.num_shells_on_centre > 0)
        assert sum(num_orbs_per_shelltype[self.shelltype]) == self.num_atorbs

        self.num_spins = 1+self.spin_unrestricted
        assert len(self.coeff) == self.num_spins
        for sp in range(self.num_spins):
            assert self.coeff[sp].shape == (self.num_molorbs[sp],self.num_atorbs)
            assert self.coeff[sp].dtype == np.float64
        self.coeff_norm = [
            self.coeff[sp][:,:] * self.get_norm()[None,:]
            for sp in range(self.num_spins)
        ]


    def writefile(self,fname):
        f = open(fname,"w")

        def writeline(l=""):
            f.write(l+"\n")
        def writestr(s):
            writeline(" "+s)
        def writeint(i):
            writestr("%i"%i)
        def writefloat(f):
            writestr("%.15f"%f)
        def writefloats(F,num_cols=4):
            N = len(F)
            for c in range(0,N-num_cols+1,num_cols):
                writeline(("% .13E"*num_cols)%tuple(F[c:c+num_cols]))
            if N%num_cols:
                writeline(("% .13E"*(N%num_cols))%tuple(F[-(N%num_cols):]))
        def writeints(I,num_cols=8):
            N = len(I)
            for c in range(0,N-num_cols+1,num_cols):
                writeline(("% 10i"*num_cols)%tuple(I[c:c+num_cols]))
            if N%num_cols:
                writeline(("% 10i"*(N%num_cols))%tuple(I[-(N%num_cols):]))
        def writebool(b):
            return writestr(P2F_bool[b])

        writeline(self.title)
        writeline()
        writeline("BASIC INFO")
        writeline("----------")
        writeline("Generated by:")
        writestr(self.code)
        writeline("Periodicity:")
        writeint(self.periodicity)
        writeline("Spin unrestricted:")
        writebool(self.spin_unrestricted)
        writeline("Nuclear repulsion energy (au/atom):")
        writefloat(self.nuclear_repulsion_energy)
        writeline("Number of electrons")
        writeint(self.num_elec)
        writeline()
        writeline("GEOMETRY")
        writeline("--------")
        writeline("Number of atoms")
        writeint(self.num_atom)
        writeline("Atomic positions (au)")
        writefloats(self.atompos.reshape((self.num_atom*3)),num_cols=3)
        writeline("Atomic numbers for each atom")
        writeints(self.atomnum)
        writeline("Valence charges for each atom")
        writefloats(self.atomcharge)
        writeline()
        writeline("BASIS SET")
        writeline("---------")
        writeline("Number of STO centres")
        writeint(self.num_centres)
        writeline("Position of each centre (au)")
        writefloats(self.centrepos.reshape((self.num_centres*3)),num_cols=3)
        writeline("Number of shells")
        writeint(self.num_shells)
        writeline("Sequence number of first shell on each centre")
        writeints(self.idx_first_shell_on_centre[:-1]+1)
        writeline("Code for shell types (s/sp/p/d/f/g 1/2/3/4/5/6)")
        writeints(self.shelltype)
        writeline("Order of radial prefactor r in each shell")
        writeints(self.order_r_in_shell)
        writeline("Exponent in each STO shell")
        writefloats(self.zeta)
        writeline("Number of basis functions ('AO')")
        writeint(self.num_atorbs)
        writeline("Number of molecular orbitals ('MO')")
        writeints(self.num_molorbs)
        writeline()
        writeline("MULTIDETERMINANT INFORMATION")
        writeline("----------------------------")
        writeline("GS")
        writeline()

        if hasattr(self,"coeff_norm"):
            writeline("ORBITAL COEFFICIENTS (normalized AO)")
            writeline("------------------------------------")
            coeff = self.coeff_norm[0][:,:] / self.get_norm()[None,:]
            writefloats(coeff.reshape((self.num_molorbs[0]*self.num_atorbs)))
            if self.spin_unrestricted:
                coeff = self.coeff_norm[1][:,:] / self.get_norm()[None,:]
                writefloats(coeff.reshape((self.num_molorbs[1]*self.num_atorbs)))
            writeline()
        elif hasattr(self,"coeff"):
            writeline("ORBITAL COEFFICIENTS (normalized AO)")
            writeline("------------------------------------")
            writefloats(self.coeff[0].reshape((self.num_molorbs[0]*self.num_atorbs)))
            if self.spin_unrestricted:
                writefloats(self.coeff[1].reshape((self.num_molorbs[1]*self.num_atorbs)))
            writeline()

        f.writelines(self.footer)
        f.close()

    def read_molorbmods(self,fname="correlation.data"):
        l = [ l.strip() for l in open(fname,"r").readlines() ]
        start = l.index("START MOLORBMODS")+3
        end = l.index("END MOLORBMODS")
        while start < end:
            if l[start] == "START MOLECULAR ORBITAL COEFFICIENTS":
                endcoeff = l.index("END MOLECULAR ORBITAL COEFFICIENTS")
                moc = [ float(c.split()[0]) for c in l[start+2:endcoeff] ]
                start = endcoeff+1
            elif l[start] == "START STO EXPONENT ZETAS":
                endzeta = l.index("END STO EXPONENT ZETAS")
                zet = [ float(c.split()[0]) for c in l[start+2:endzeta] ]
                start = endzeta+1
            else:
                raise "unknown block starting with '"+l[start]+"'"

    def eval_molorbs(self, pos, spin=0):
        num_points = pos.shape[1]
        assert pos.shape == (3, num_points)
        num_molorbs = self.num_molorbs[spin]
        val = np.zeros((num_points, num_molorbs))

        stowfn_cpp.eval_molorbs(
            pos.astype(float),  # (3, num_points)
            np.asarray(self.num_shells_on_centre, dtype=np.int32),  # (num_centres,)
            np.asarray(self.shelltype, dtype=np.int32),  # (num_shells_total,)
            np.asarray(self.order_r_in_shell, dtype=np.int32),  # (num_shells_total,)
            np.asarray(self.max_shell_type_on_centre, dtype=np.int32),  # (num_centres,)
            np.asarray(self.zeta, dtype=float),  # (num_shells_total,)
            self.centrepos.astype(float),  # (num_centres, 3)
            np.asarray(self.coeff_norm[spin], dtype=float),  # (num_molorbs, num_atorbs)
            val  # output (num_points, num_molorbs)
        )

        return val

    def eval_molorb_derivs(self, pos, spin=0):
        num_points = pos.shape[1]
        assert pos.shape == (3, num_points)
        num_molorbs = self.num_molorbs[spin]

        val = np.zeros((num_points, num_molorbs))
        grad = np.zeros((3, num_points, num_molorbs))
        lap = np.zeros((num_points, num_molorbs))

        stowfn_cpp.eval_molorb_derivs(
            pos.astype(float),  # (3, num_points)
            np.asarray(self.num_shells_on_centre, dtype=np.int32),  # (num_centres,)
            np.asarray(self.shelltype, dtype=np.int32),  # (num_shells_total,)
            np.asarray(self.order_r_in_shell, dtype=np.int32),  # (num_shells_total,)
            np.asarray(self.max_shell_type_on_centre, dtype=np.int32),  # (num_centres,)
            np.asarray(self.zeta, dtype=float),  # (num_shells_total,)
            self.centrepos.astype(float),  # (num_centres,3)
            np.asarray(self.coeff_norm[spin], dtype=float),  # (num_molorbs,num_atorbs)
            val,  # (num_points,num_molorbs) output
            grad,  # (3,num_points,num_molorbs) output
            lap  # (num_points,num_molorbs) output
        )

        return val, grad, lap

    def eval_atorbs(self, pos):
        num_points = pos.shape[1]
        assert pos.shape == (3,num_points)
        atorbs = np.zeros((num_points,self.num_atorbs))
        stowfn_cpp.eval_atorbs(
            pos.astype(float),  # (3,num_points)
            self.centrepos.astype(float),  # (num_centres,3)
            np.asarray(self.num_shells_on_centre, dtype=np.int32),  # (num_centres,)
            np.asarray(self.max_shell_type_on_centre, dtype=np.int32),  # (num_centres,)
            np.asarray(self.shelltype, dtype=np.int32),  # (num_shells_total,)
            np.asarray(self.order_r_in_shell, dtype=np.int32),  # (num_shells_total,)
            np.asarray(self.zeta, dtype=float),  # (num_shells_total,)
            atorbs  # output
        )
        return atorbs

    def get_norm(self):
        norm = np.zeros((self.num_atorbs,))
        stowfn_cpp.compute_norm(
            np.array(self.num_shells_on_centre, dtype=np.int32),
            np.array(self.shelltype, dtype=np.int32),
            np.array(self.order_r_in_shell, dtype=np.int32),
            np.array(self.zeta, dtype=float),
            norm,
        )
        return norm

    def iter_atorbs(self):
        nshell = 0
        atorb = 0
        for centre in range(self.num_centres):
            for _shell in range(self.num_shells_on_centre[centre]):
                for pl in range(num_orbs_per_shelltype[self.shelltype[nshell]]):
                    yield (atorb,centre,nshell,self.order_r_in_shell[nshell],pl)
                    atorb += 1
                nshell += 1

    def cusp_constraint_matrix(self):
        norm = self.get_norm()
        res = np.asmatrix(np.zeros((self.num_centres,self.num_atorbs)))
        for core in range(self.num_centres):
            atorb_vals = self.eval_atorbs(self.centrepos[core][:,None])[0,:]
            for (atorb,centre,nshell,N,_pl) in self.iter_atorbs():
                if centre == core:
                    if self.shelltype[nshell] == 1:
                        if N == 0:
                            res[core,atorb] = norm[atorb] * (self.atomcharge[core] - self.zeta[nshell])
                        elif N == 1:
                            res[core,atorb] = norm[atorb]
                else: # centre != core
                    res[core,atorb] = norm[atorb]*self.atomcharge[core]*atorb_vals[atorb]
        return res

    def cusp_projection_matrix(self):
        #print "cusp_constraint: ",cusp_constraint
        _U,_S,Vh = np.linalg.svd(self.cusp_constraint_matrix(),full_matrices=False)
        #print "shapes U,S,Vh",U.shape,S.shape,Vh.shape
        P = Vh.T * Vh
        #print "proj shape",cusp_constraint_projector.shape
        #print "proj trace",P.trace()
        #print "proj squarediff",np.linalg.norm(P - P*P)
        Q = np.eye(P.shape[0]) - P
        return Q

    def cusp_fixed_atorbs(self):
        res = np.zeros(self.num_centres,int)
        for c in range(self.num_centres):
            cidx = np.zeros(self.num_shells)
            cidx[self.idx_first_shell_on_centre[c]:self.idx_first_shell_on_centre[c+1]] = 1.0
            shell = np.argmax(self.zeta * cidx * (self.shelltype == 1))
            res[c] = num_orbs_per_shelltype[self.shelltype[:shell]].sum()
        return res

    def cusp_enforcing_matrix(self):
        cusp_fixed_atorb = self.cusp_fixed_atorbs()
        constraint = self.cusp_constraint_matrix()
        res = constraint + 0.0
        res[:,cusp_fixed_atorb] = 0.0
        U,S,Vh = np.linalg.svd(constraint[:,cusp_fixed_atorb],full_matrices=False)
        tmpinv = Vh.T * np.asmatrix(np.diag(1/S)) * U.T
        res = -tmpinv * res
        mat = np.asmatrix(np.eye(self.num_atorbs))
        mat[cusp_fixed_atorb,:] = res
        return mat


if __name__ == "__main__":
    sto = stowfn("stowfn.data")
    sto.read_molorbmods("correlation.data")
    points = np.zeros((3,4))
    points[:,0] = (-0.19450689,-0.94412413,-0.67370571)
    points[:,:] = points[:,:1]
    points[0,1] += 0.00317100
    points[1,2] += 0.00317100
    points[2,3] += 0.00317100
    val,grad,lap = sto.eval_molorb_derivs(points)
    print("grad analytic:",grad[:,0])
    print("grad numeric:",(val[1:]-val[0])/0.00317100)
#    print sto.get_norm()
#    sto.writefile("stowfn.data.out")
